<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Decomposing price indexes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="decomposing-indexes_files/libs/clipboard/clipboard.min.js"></script>
<script src="decomposing-indexes_files/libs/quarto-html/quarto.js"></script>
<script src="decomposing-indexes_files/libs/quarto-html/popper.min.js"></script>
<script src="decomposing-indexes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="decomposing-indexes_files/libs/quarto-html/anchor.min.js"></script>
<link href="decomposing-indexes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="decomposing-indexes_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="decomposing-indexes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="decomposing-indexes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="decomposing-indexes_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decomposing price indexes</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>This vignette presents an extended version of <span class="citation" data-cites="martin2021">Martin (<a href="#ref-martin2021" role="doc-biblioref">2021</a>)</span>, and shows how to use the tools in this package to make these decompositions.</em></p>
<p>It is often useful to be able to decompose a price index into an additive or multiplicative form to evaluate how each input to the index affects its value. Following <span class="citation" data-cites="balk2008">Balk (<a href="#ref-balk2008" role="doc-biblioref">2008</a>)</span>, a price index is said to admit an additive decomposition if there exist weights that allow it to be represented as an arithmetic mean of price relatives, and is said to admit a multiplicative decomposition if there are weights that allow it to be represented as a geometric mean. Switching prices for quantities gives the analogous statements for a quantity index, and nothing is lost by focusing on price indexes.</p>
<p>There are a number of well-known decompositions for the most common types of bilateral price indexes. <span class="citation" data-cites="balk2008">Balk (<a href="#ref-balk2008" role="doc-biblioref">2008</a>, equation 4.13)</span> gives an additive decomposition for any index based on the geometric mean by transmuting the weights in the geometric mean with the logarithmic mean. This is the same decomposition derived by <span class="citation" data-cites="reinsdorf2002">Reinsdorf, Diewert, and Ehemann (<a href="#ref-reinsdorf2002" role="doc-biblioref">2002</a>, equation 20)</span> for the TÃ¶rnqvist index. A similar approach yields a multiplicative decomposition for any index based on the arithmetic mean, again using the logarithmic mean <span class="citation" data-cites="balk2008">(<a href="#ref-balk2008" role="doc-biblioref">Balk 2008</a>, equation 4.8)</span>. Combining these results gives additive and multiplicative decompositions for the Fisher index <span class="citation" data-cites="reinsdorf2002">(<a href="#ref-reinsdorf2002" role="doc-biblioref">Reinsdorf, Diewert, and Ehemann 2002, sec. 6</a>)</span>. The van IJzeren additive decomposition for the Fisher index <span class="citation" data-cites="balk2008">(<a href="#ref-balk2008" role="doc-biblioref">Balk 2008</a>, equation 4.18)</span> is an alternative that does not use the logarithmic mean. Each of these decompositions results in weights that are positive and sum to one, as required to represent an index as an arithmetic or geometric mean.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>I show how the additive and multiplicative decompositions for geometric, arithmetic, and Fisher indexes that use the logarithmic mean can be consolidated and made more general by switching out the logarithmic mean for the more general extended mean. The main result is a function that transmutes the weights in a generalized mean of a given order so that it can be represented as a generalized mean of any other order. This covers additive and multiplicative decompositions for indexes that do not belong to the arithmetic or geometric families, like harmonic indexes or the Lloyd-Moulton index, and allows both additive and multiplicative decompositions to be covered by a single equation, rather than treating them as different cases. Expressing a generalized index as a generalized mean of any other order also allows for the decomposition of indexes that are nested generalized means, like the family of superlative quadratic mean indexes that includes the Fisher index, the AG mean index by <span class="citation" data-cites="lent2009">Lent and Dorfman (<a href="#ref-lent2009" role="doc-biblioref">2009</a>)</span>, or GEKS indexes <span class="citation" data-cites="webster2019">(<a href="#ref-webster2019" role="doc-biblioref">Webster and Tarnow-Mordi 2019</a>)</span>.</p>
<section id="sec-decompose" class="level2">
<h2 class="anchored" data-anchor-id="sec-decompose">Decomposing generalized-mean indexes</h2>
<p>A natural extension to the decompositions for indexes based on the arithmetic and geometric means is to derive weights that transform an index based on a generalized mean of order <span class="math inline">\(\rho\)</span> into one based on a generalized mean of order <span class="math inline">\(\varsigma\)</span>. To fix notation, let <span class="math inline">\(\mathbf{r} = (r_{1}, r_{2}, \ldots, r_{n}) \in \mathbb{R}^{n}_{++}\)</span> be a vector of price relatives for <span class="math inline">\(n\geq2\)</span> products and let <span class="math inline">\(\mathbf{w} = (w_{1}, w_{2}, \ldots, w_{n}) \in \Delta^{n - 1}\)</span> be the corresponding weights, where <span class="math inline">\(\Delta^{n - 1} = \{\mathbf{w} \in \mathbb{R}_{+}^{n} | \sum_{i = 1}^{n} w_{i} = 1\}\)</span> is the unit simplex. The goal is to find a vector-valued function <span class="math display">\[
\mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) = (v_{1}(\mathbf{r}, \mathbf{w}; \rho, \varsigma), v_{2}(\mathbf{r}, \mathbf{w}; \rho, \varsigma),\ldots, v_{n}(\mathbf{r}, \mathbf{w}; \rho, \varsigma))
\]</span> mapping into <span class="math inline">\(\Delta^{n - 1}\)</span> such that <span class="math display">\[
\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w}) \equiv \mathfrak{M}_{\varsigma}(\mathbf{r}, \mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma)),
\]</span> where <span class="math inline">\(\mathfrak{M}_{\rho}\)</span> is the generalized mean <span class="math display">\[
\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w}) =
\begin{cases}
\left(\sum_{i = 1}^{n} w_{i} r_i^{\rho}\right)^{1 / \rho} &amp; \text{if } \rho \neq 0 \\
\prod_{i = 1}^{n} r_{i}^{w_{i}} &amp; \text{if } \rho = 0.
\end{cases}
\]</span></p>
<p>Setting <span class="math inline">\(\varsigma = 1\)</span> then yields an additive decomposition for any index based on a generalized mean of order <span class="math inline">\(\rho\)</span>, such that <span class="math display">\[
\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w}) = \sum_{i=1}^{n} r_{i} v_i(\mathbf{r}, \mathbf{w}; \rho, 1),
\]</span> and setting <span class="math inline">\(\varsigma = 0\)</span> yields a multiplicative decomposition, such that <span class="math display">\[
\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w}) = \prod_{i=1}^{n} r_{i}^{ v_i(\mathbf{r}, \mathbf{w}; \rho, 0)}.
\]</span> Note that any index that admits an additive decomposition can be used to derive percent-change contributions for each price relative, <span class="math inline">\(v_i(\mathbf{r}, \mathbf{w}; \rho, 1) (r_i - 1)\)</span>, that sum up to <span class="math inline">\(\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w}) - 1\)</span>. I examine these types of contributions in more detail in <a href="#sec-contribution" class="quarto-xref">Section&nbsp;2</a>.</p>
<p><span class="citation" data-cites="balk2008">Balk (<a href="#ref-balk2008" role="doc-biblioref">2008</a>)</span> and <span class="citation" data-cites="reinsdorf2002">Reinsdorf, Diewert, and Ehemann (<a href="#ref-reinsdorf2002" role="doc-biblioref">2002</a>)</span> show how to derive <span class="math inline">\(\mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma)\)</span> when <span class="math inline">\(\rho = 1\)</span> and <span class="math inline">\(\varsigma = 0\)</span> (multiplicative decomposition of an arithmetic index) <span class="math display">\[
v_{i}(\mathbf{r}, \mathbf{w}; 1, 0) = \frac{w_{i} \mathfrak{L}(r_{i}, \mathfrak{M}_{1}(\mathbf{r}, \mathbf{w}))}{\sum_{j=1}^{n} w_{j} \mathfrak{L}(r_{j}, \mathfrak{M}_{1}(\mathbf{r}, \mathbf{w}))}
\]</span> and <span class="math inline">\(\rho = 0\)</span> and <span class="math inline">\(\varsigma = 1\)</span> (additive decomposition of a geometric index) <span class="math display">\[
v_{i}(\mathbf{r}, \mathbf{w}; 0, 1) = \frac{w_{i} / \mathfrak{L}(r_{i}, \mathfrak{M}_{0}(\mathbf{r}, \mathbf{w}))}{\sum_{j=1}^{n} w_{j} / \mathfrak{L}(r_{j}, \mathfrak{M}_{0}(\mathbf{r}, \mathbf{w}))},
\]</span> using the logarithmic mean <span class="math display">\[
\mathfrak{L}(a, b) =
\begin{cases}
\frac{a - b}{log(a / b)} &amp; a \neq b\\
a &amp; a = b.
\end{cases}
\]</span></p>
<p>Generalizing these results follows from replacing the logarithmic mean with the more general extended mean <span class="citation" data-cites="bullen2003">(<a href="#ref-bullen2003" role="doc-biblioref">Bullen 2003, 393</a>)</span>, defined for any <span class="math inline">\(a,b &gt; 0\)</span> as <span class="math display">\[
\mathfrak{E}_{\rho\varsigma}(a, b) =
\begin{cases}
\left(\frac{\varsigma(a^\rho - b^\rho)}{\rho(a^\varsigma - b^\varsigma)}\right)^{1 / (\rho - \varsigma)} &amp; \rho \neq \varsigma, \rho \neq 0, \varsigma \neq 0, a \neq b \\
\left(\frac{a^\rho - b^\rho}{\rho\log(a / b)}\right)^{1 / \rho} &amp; \rho \neq 0, \varsigma = 0, a \neq b \\
\left(\frac{a^\varsigma - b^\varsigma}{\varsigma\log(a / b)}\right)^{1 / \varsigma} &amp; \rho = 0, \varsigma \neq 0, a \neq b \\
\frac{1}{\exp(1 / \rho)} \left(\frac{a^{a^\rho}}{b^{b^\rho}}\right)^{1 / (a^\rho - b^\rho)} &amp; \rho = \varsigma  \neq 0, a \neq b \\
\sqrt{ab} &amp; \rho = \varsigma = 0, a \neq b \\
a &amp; a = b.
\end{cases}
\]</span> The extended mean reduces to the logarithmic mean when either <span class="math inline">\(\rho = 0\)</span> and <span class="math inline">\(\varsigma = 1\)</span>, or <span class="math inline">\(\rho = 1\)</span> and <span class="math inline">\(\varsigma = 0\)</span>. But using the extended mean in place of the logarithmic mean allows for decompositions of indexes based on other types of means, like harmonic indexes (<span class="math inline">\(\varsigma = -1\)</span>) and the Lloyd-Moulton index (<span class="math inline">\(\varsigma = 1 - \sigma\)</span>, where <span class="math inline">\(\sigma\)</span> is an elasticity of substitution).</p>
<p>The key to transforming the weights in a generalized mean of order <span class="math inline">\(\rho\)</span> into the weights for a generalized mean of order <span class="math inline">\(\varsigma\)</span> comes from noting that the extended mean is always strictly positive and satisfies the identity <span id="eq-identity"><span class="math display">\[
\sum_{i=1}^{n} w_{i} \mathfrak{E}_{\rho\varsigma}(r_i, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma} \varepsilon(\mathbf{r}, \mathbf{w}; \rho, \varsigma) \equiv 0,
\tag{1}\]</span></span> where <span class="math display">\[
\varepsilon(\mathbf{r}, \mathbf{w}; \rho, \varsigma) =
\begin{cases}
r_i^\varsigma - \mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w})^\varsigma &amp; \text{if } \varsigma \neq 0, \\
\log(r_i) - \log(\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w})) &amp; \text{if } \varsigma = 0.
\end{cases}
\]</span> <a href="#eq-identity" class="quarto-xref">Equation&nbsp;1</a> uses the extended mean to keep the weighted deviation from the mean constant for each price relative (up to a common factor of proportionality) when changing the order of the mean from <span class="math inline">\(\rho\)</span> to <span class="math inline">\(\varsigma\)</span>, without changing the value of the mean. Rearranging then gives that <span id="eq-res1"><span class="math display">\[
v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) =  w_{i} \mathfrak{E}_{\rho\varsigma}(r_i, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma} \Bigg/ \sum_{j=1}^{n} w_{j} \mathfrak{E}_{\rho\varsigma}(r_j, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma}
\tag{2}\]</span></span> is a suitable function to find weights that turn an index based on a generalized mean of order <span class="math inline">\(\rho\)</span> into one based on a generalized mean of order <span class="math inline">\(\varsigma\)</span>.</p>
<p>The decomposition in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> has a number of useful properties. Transmuting the weights to turn a generalized mean of order <span class="math inline">\(\rho\)</span> into a generalized mean of order <span class="math inline">\(\varsigma\)</span>, and then transmuting these weights again to turn a generalized mean of order <span class="math inline">\(\varsigma\)</span> into a generalized mean of order <span class="math inline">\(\rho\)</span> returns the original weights.</p>
<div id="prp-invariance" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 (Invariance)</strong></span> The decomposition given by <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> has the following properties.</p>
<ol type="1">
<li><span class="math inline">\(\mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \rho) = \mathbf{w}\)</span>.</li>
<li><span class="math inline">\(\mathbf{v}(\mathbf{r}, \mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma); \varsigma, \rho) = \mathbf{w}\)</span>.</li>
<li><span class="math inline">\(w_{k} v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) = w_{i} v_{k}(\mathbf{r}, \mathbf{w}; \rho, \varsigma)\)</span> when <span class="math inline">\(r_{i} = r_{k}\)</span>.</li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span></p>
<ol type="1">
<li>Since the extended mean is strictly positive, <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \rho) = w_{i} / \sum_{j=1}^{n} w_{j} = w_{i}\)</span> because <span class="math inline">\(\sum_{j=1}^{n} w_{j}=1\)</span>.</li>
<li>From the definition of the extended mean, <span class="math inline">\(\mathfrak{E}_{\rho\varsigma}(a, b) = \mathfrak{E}_{\varsigma\rho}(a, b)\)</span> for all <span class="math inline">\(a, b\)</span>. This means that <span class="math inline">\(\mathfrak{E}_{\rho\varsigma}(r_i, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma}\mathfrak{E}_{\varsigma\rho}(r_i, \mathfrak{M}_{\varsigma}(\mathbf{r}, \mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma)))^{\varsigma - \rho} = 1\)</span> for each <span class="math inline">\(i=1,...,n\)</span> because <span class="math inline">\(\mathfrak{M}_{\rho}(\mathbf{r}, \mathbf{w}) = \mathfrak{M}_{\varsigma}(\mathbf{r}, \mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma))\)</span>. Plugging into <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> gives the result.</li>
<li>If <span class="math inline">\(r_{i} = r_{k}\)</span> then <span class="math display">\[\begin{align*}
w_{k} v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) &amp;=  w_{k}w_{i}\mathfrak{E}_{\rho\varsigma}(r_k, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma} \Bigg/ \sum_{j=1}^{n} w_{j} \mathfrak{E}_{\rho\varsigma}(r_j, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma}\\
&amp;= w_{i} v_{k}(\mathbf{r}, \mathbf{w}; \rho, \varsigma).
\end{align*}\]</span></li>
</ol>
</div>
<p>An implication of invariance is the <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> is the unique decomposition for indexes based on the generalized mean.</p>
<div id="prp-unique" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 (Uniqueness)</strong></span> The decomposition in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> is the only such decomposition that is invariant in the sense of <a href="#prp-invariance" class="quarto-xref">Proposition&nbsp;1</a>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>When <span class="math inline">\(n=2\)</span>, any other function <span class="math inline">\(\mathbf{u}\)</span> that decomposes the generalized mean must satisfy <span class="math inline">\((v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) - u_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma))(r_{1}^\varsigma - r_{2}^\varsigma) \equiv 0\)</span> for <span class="math inline">\(i=1,2\)</span>, or <span class="math inline">\((v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) - u_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma))(\log(r_{1}) - \log(r_{2})) \equiv 0\)</span> when <span class="math inline">\(\varsigma = 0\)</span>, so that <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) \equiv u_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma)\)</span> whenever <span class="math inline">\(r_{1} \neq r_{2}\)</span>. This means that, for some <span class="math inline">\(\rho\)</span>, there is an <span class="math inline">\(\mathbf{r}\)</span> and <span class="math inline">\(\mathbf{w}\)</span> such that <span class="math inline">\(\mathbf{u}(\mathbf{r}, \mathbf{w}; \rho, \rho) \neq \mathbf{w}\)</span>.</p>
<p>Now suppose <span class="math inline">\(n\geq3\)</span> and <span class="math inline">\(r_1\neq r_2 \neq r_3 = \ldots = r_n\)</span> and <span class="math inline">\(w_{3} = \ldots = w_{n}\)</span>. Any other weights that successfully decompose the generalized mean of order <span class="math inline">\(\rho\)</span> and are invariant must satisfy <span class="math display">\[
\mathfrak{M}_\rho(\mathbf{r}, \mathbf{w})^\varsigma = (v_{1}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_1) r_1^\varsigma + (v_{2}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_2) r_2^\varsigma + (n - 2) (v_{3}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_3) r_3^\varsigma
\]</span> for some <span class="math inline">\((\delta_1, \delta_2, \delta_3)\)</span>. This implies that <span class="math display">\[
\delta_1 r_1^\varsigma + \delta_2 r_2^\varsigma = -(n -2)\delta_3r_3^\varsigma
\]</span> It also must be that these weights sum to 1, so that <span class="math display">\[
\delta_1 + \delta_2 = -(n - 2)\delta_3.
\]</span> Therefore <span class="math display">\[
\delta_2 = \delta_1 \frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma}.
\]</span> Decomposing these weights again requires that <span class="math display">\[
v_{1}(\mathbf{r}, v_{1}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_1; \varsigma, \rho) + \eta_1 = w_{1}
\]</span> and <span class="math display">\[
v_{2}\left(\mathbf{r}, v_{2}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_1 \frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma}; \varsigma, \rho\right) + \eta_1\frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma} = w_2
\]</span> for some <span class="math inline">\(\eta_1\)</span>. Using the invariance of <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> implies that <span class="math display">\[
\delta_1 \mathfrak{E}_{\varsigma\rho}(r_2, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w})) = \eta_1 \mathfrak{E}_{\varsigma\rho}(r_1, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w})).
\]</span> As <span class="math inline">\(r_1 \neq r_2\)</span>, this can only be true if <span class="math inline">\(\delta_1=0\)</span>.</p>
</div>
<p>The function in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> has a monotonicity property where the weights increase (decrease) for large (small) price relatives if and only if <span class="math inline">\(\rho &gt; \varsigma\)</span>.</p>
<div id="prp-monotone" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3 (Monotonicity)</strong></span> Assuming <span class="math inline">\(\mathbf{r}\)</span> is ordered from smallest to largest (and does not contain all the same value), if <span class="math inline">\(\rho &gt; \varsigma\)</span> then there is a pair of integer <span class="math inline">\(k,l\)</span>, with <span class="math inline">\(k\leq l\)</span>, such that <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) &gt; w_{i}\)</span> for <span class="math inline">\(i\geq l\)</span> and <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) &lt; w_{i}\)</span> for <span class="math inline">\(i\leq k\)</span>, with these equalities reversed if <span class="math inline">\(\rho &lt; \varsigma\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>To start, note that <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) \geq w_{i}\)</span> if and only if <span class="math display">\[
\mathfrak{E}_{\rho\varsigma}(r_i, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma} \geq \sum_{j=1}^{n} w_{j} \mathfrak{E}_{\rho\varsigma}(r_j, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma}.
\]</span> Since the extended mean is strictly increasing in its first argument <span class="citation" data-cites="bullen2003">(<a href="#ref-bullen2003" role="doc-biblioref">Bullen 2003</a>, theorem 16)</span>, the right-hand side is an increasing function if <span class="math inline">\(\rho &gt; \varsigma\)</span>. This inequality is not satisfied for <span class="math inline">\(i=1\)</span> and is strictly satisfied for <span class="math inline">\(i=n\)</span>, so <span class="math inline">\(k\)</span> can then be set to the largest value such that this inequality is not satisfied, and <span class="math inline">\(l\)</span> can be set to the smallest value such that it is strictly satisfied. If <span class="math inline">\(\rho &lt; \varsigma\)</span> then the right-hand side is a decreasing function, so the inequality is not satisfied for <span class="math inline">\(i=n\)</span> and is strictly satisfied for <span class="math inline">\(i=1\)</span>. As before, <span class="math inline">\(k\)</span> can be set to the largest value such that the inequality is strictly satisfied, and <span class="math inline">\(l\)</span> can be set to the smallest value such that it is not satisfied.</p>
</div>
<p>The function given by <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> takes on all existing decompositions that I know of as special cases. Setting <span class="math inline">\(\rho = 0\)</span> and <span class="math inline">\(\varsigma = 1\)</span>, or <span class="math inline">\(\rho = 1\)</span> and <span class="math inline">\(\varsigma = 0\)</span>, gives the special cases by <span class="citation" data-cites="balk2008">Balk (<a href="#ref-balk2008" role="doc-biblioref">2008</a>)</span> and <span class="citation" data-cites="reinsdorf2002">Reinsdorf, Diewert, and Ehemann (<a href="#ref-reinsdorf2002" role="doc-biblioref">2002</a>)</span> for decomposing indexes based on arithmetic and geometric means (because the extended mean reduces to the logarithmic mean). Similarly, setting <span class="math inline">\(\rho = -1\)</span> and <span class="math inline">\(\varsigma = 1\)</span> reduces <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> to <span class="math display">\[
v_{i}(\mathbf{r}, \mathbf{w}; -1, 1) = \frac{w_{i} / r_{i}}{\sum_{i=1}^{n}w_{i} / r_{i}} ;
\]</span> if <span class="math inline">\(\mathbf{w}\)</span> is a vector of current-period expenditure/revenue shares then these are the hybrid weights that allow a Paasche index to be calculated as an arithmetic mean of price relatives. Similarly, setting <span class="math inline">\(\rho = 1\)</span> and <span class="math inline">\(\varsigma = -1\)</span> reduces <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> to <span class="math display">\[
v_{i}(\mathbf{r}, \mathbf{w}; 1, -1) = \frac{w_{i} r_{i}}{\sum_{i=1}^{n}w_{i} r_{i}}.
\]</span> If <span class="math inline">\(\mathbf{w}\)</span> is a vector of base-period expenditure/revenue shares then these are the hybrid weights that allow a Laspeyres index to be calculated as a harmonic mean of price relatives.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> As should be expected, the weights are unchanged if <span class="math inline">\(\rho = \varsigma\)</span> or each element of <span class="math inline">\(\mathbf{r}\)</span> takes on the same value.</p>
<section id="invariance-and-monotonicity-properties" class="level3">
<h3 class="anchored" data-anchor-id="invariance-and-monotonicity-properties">Invariance and monotonicity properties</h3>
<p>The extended mean has two properties that make it useful for decomposing price indexes. First, the order of <span class="math inline">\(\rho\)</span> and <span class="math inline">\(\varsigma\)</span> do not matter in the extended mean: <span class="math inline">\(\mathfrak{E}_{\rho\varsigma}(a, b) = \mathfrak{E}_{\varsigma\rho}(a, b)\)</span>. This means the function in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> has an invariance property such that transmuting the weights to turn a generalized mean of order <span class="math inline">\(\rho\)</span> into a generalized mean of order <span class="math inline">\(\varsigma\)</span>, and then transmuting these weights again to turn a generalized mean of order <span class="math inline">\(\varsigma\)</span> into a generalized mean of order <span class="math inline">\(\rho\)</span> returns the original weights. That is, <span class="math display">\[
\mathbf{v}(\mathbf{r}, \mathbf{v}(\mathbf{r}, \mathbf{w}; \rho, \varsigma); \varsigma, \rho) \equiv \mathbf{w}.
\]</span> As will be seen later, not all decompositions have this property.</p>
<p>Second, the extended mean is a strictly increasing function in both arguments <span class="citation" data-cites="bullen2003">(<a href="#ref-bullen2003" role="doc-biblioref">Bullen 2003</a>, theorem 16)</span>. This means that the function in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> has a monotonicity property where the weights increase (decrease) for large (small) price relatives if and only if <span class="math inline">\(\rho &gt; \varsigma\)</span>. That is, assuming <span class="math inline">\(\mathbf{r}\)</span> is ordered from smallest to largest (and does not contain all the same value), if <span class="math inline">\(\rho &gt; \varsigma\)</span> then there is a pair of integer <span class="math inline">\(k,l\)</span>, with <span class="math inline">\(k\leq l\)</span>, such that <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) &gt; w_{i}\)</span> for <span class="math inline">\(i\geq l\)</span> and <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) &lt; w_{i}\)</span> for <span class="math inline">\(i\leq k\)</span>, with these equalities reversed if <span class="math inline">\(\rho &lt; \varsigma\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Again, not all decompositions satisfy this property.</p>
</section>
<section id="uniqueness-1" class="level3">
<h3 class="anchored" data-anchor-id="uniqueness-1">Uniqueness</h3>
<p>The decomposition given by <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> is unique when <span class="math inline">\(n = 2\)</span> and <span class="math inline">\(r_{1} \neq r_{2}\)</span>, and is the only such function that always returns <span class="math inline">\(\mathbf{w}\)</span> when <span class="math inline">\(r_{1} = r_{2}\)</span>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> But <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> is necessarily not unique when <span class="math inline">\(n\geq3\)</span>, and there are infinitely many ways to decompose an index based on the generalized mean.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> What makes <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> unique is that it is the only invariant decomposition of the generalized mean for <span class="math inline">\(n\geq3\)</span>.</p>
<p>To see this, suppose <span class="math inline">\(n=3\)</span> and <span class="math inline">\(r_1\neq r_2 \neq r_3\)</span>. Any other weights that successfully decompose the generalized mean of order <span class="math inline">\(\rho\)</span> can be written as <span class="math display">\[
\begin{pmatrix}
v_{1}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_\rho\\
v_{2}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_\rho \frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma}\\
1 - v_{1}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) - \delta_\rho - v_{2}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) - \delta_\rho \frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma}
\end{pmatrix}
\]</span> for some <span class="math inline">\(\delta_\rho\)</span>. Decomposing these weights again requires that <span class="math display">\[
v_{1}(\mathbf{r}, v_{1}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_\rho; \varsigma, \rho) + \delta_\varsigma = w_{1}
\]</span> and <span class="math display">\[
v_{2}\left(\mathbf{r}, v_{2}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) + \delta_\rho \frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma}; \varsigma, \rho\right) + \delta_\varsigma\frac{r_3^\varsigma - r_1^\varsigma}{r_2^\varsigma - r_3^\varsigma} = w_2
\]</span> for some <span class="math inline">\(\delta_\varsigma\)</span>. Using the invariance of <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> implies that <span class="math display">\[
\delta_\rho \mathfrak{E}_{\varsigma\rho}(r_2, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w})) = \delta_\rho \mathfrak{E}_{\varsigma\rho}(r_1, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w})).
\]</span> As <span class="math inline">\(r_1 \neq r_2\)</span>, this can only be true if <span class="math inline">\(\delta_\rho=0\)</span>.</p>
</section>
<section id="decomposing-superlative-indexes" class="level3">
<h3 class="anchored" data-anchor-id="decomposing-superlative-indexes">Decomposing superlative indexes</h3>
<p>The additive and multiplicative decompositions for the Fisher index by <span class="citation" data-cites="reinsdorf2002">Reinsdorf, Diewert, and Ehemann (<a href="#ref-reinsdorf2002" role="doc-biblioref">2002, sec. 6</a>)</span> can be generalized in the same way as the decompositions for the arithmetic and geometric indexes by noting that the Fisher index is simply a nested generalized mean of indexes based on the generalized mean. For a pair of generalized means <span class="math inline">\(\left(\mathfrak{M}_{\rho_1}(\mathbf{r}, \mathbf{w}_1), \mathfrak{M}_{\rho_2}(\mathbf{r}, \mathbf{w}_2)\right)\)</span> mapping into <span class="math inline">\(R_2^{++}\)</span> with weights <span class="math inline">\((\omega_1, \omega_2) \in \Delta^1\)</span>, an index based on nested generalized means is written as <span id="eq-superlative"><span class="math display">\[
\mathfrak{M}_{\rho}\left((\mathfrak{M}_{\rho_1}(\mathbf{r}, \mathbf{w}_1), \mathfrak{M}_{\rho_2}(\mathbf{r}, \mathbf{w}_2)), (\omega_1, \omega_2)\right).
\tag{3}\]</span></span></p>
<p>The general family of superlative quadratic mean indexes of order <span class="math inline">\(\tau\)</span> comes from setting <span class="math inline">\(\rho = 0\)</span>, <span class="math inline">\(\rho_1 = \tau / 2\)</span>, and <span class="math inline">\(\rho_2 = -\tau / 2\)</span> when <span class="math inline">\(\omega_1 = \omega_2 = 1 / 2\)</span>, <span class="math inline">\(\mathbf{w}_1\)</span> are base-period expenditure/revenue shares, and <span class="math inline">\(\mathbf{w}_2\)</span> are current-period expenditure/revenue shares. In particular, setting <span class="math inline">\(\tau = 2\)</span> gives the Fisher index and setting <span class="math inline">\(\tau = 1\)</span> gives the implicit Walsh index. But <a href="#eq-superlative" class="quarto-xref">Equation&nbsp;3</a> covers other types of indexes as well; for example, setting each element of <span class="math inline">\(\mathbf{w}_1\)</span> and <span class="math inline">\(\mathbf{w}_2\)</span> to <span class="math inline">\(1 / n\)</span> when <span class="math inline">\(\tau = 2\)</span> gives the Carruthers-Sellwood-Ward-Dal'en index that serves as an estimator for the Fisher index, whereas <span class="math inline">\(\tau = 1\)</span> gives the Balk-Walsh index. Setting <span class="math inline">\(\rho = -1\)</span> gives the harmonic analogue of the Fisher index, which is not a superlative quadratic mean indexes of order <span class="math inline">\(\tau\)</span>. Finally, setting <span class="math inline">\(\rho = \rho_{1} = \rho_{2}\)</span> and <span class="math inline">\(\mathbf{w}_{1} = \mathbf{w}_{2}\)</span> gives an index based on a generalized mean of order <span class="math inline">\(\rho\)</span>, so that the decomposition of an index based on the generalized mean is a special case of the decomposition for <a href="#eq-superlative" class="quarto-xref">Equation&nbsp;3</a>.</p>
<p>An index of form <a href="#eq-superlative" class="quarto-xref">Equation&nbsp;3</a> can be decomposed into an index based on the generalized mean of order <span class="math inline">\(\rho\)</span> using the weights in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a>, as it can be written as the generalized mean <span class="math display">\[
\mathfrak{M}_{\rho}(\mathbf{r}, \omega_1 \mathbf{v}(\mathbf{r}, \mathbf{w}_1; \rho_1, \rho) + \omega_2\mathbf{v}(\mathbf{r}, \mathbf{w}_2; \rho_2, \rho)).
\]</span> The transformation in <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> then applies as before, just replacing <span class="math inline">\(\mathbf{w}\)</span> with the more complicated weights <span class="math inline">\(\omega_1 \mathbf{v}(\mathbf{r}, \mathbf{w}_1; \rho_1, \rho) + \omega_2\mathbf{v}(\mathbf{r}, \mathbf{w}_2, \rho_2, \rho)\)</span>, which can be written as <span id="eq-res2"><span class="math display">\[
\mathbf{v}(\mathbf{r}, \omega_1 \mathbf{v}(\mathbf{r}, \mathbf{w}_1; \rho_1, \rho) + \omega_2\mathbf{v}(\mathbf{r}, \mathbf{w}_2; \rho_2, \rho); \rho, \varsigma).
\tag{4}\]</span></span> The idea is to transmute the weights for both inner means to be of the same order as the outer mean (<span class="math inline">\(\rho\)</span>) so that they can be added together, and then transmute these weights to represent the outer generalized mean as a mean of order <span class="math inline">\(\varsigma\)</span>. Note that this means the decomposition satisfies the same invariance property as <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a>.</p>
<p>An alternative approach to decompose <a href="#eq-superlative" class="quarto-xref">Equation&nbsp;3</a> is to generalize the (additive) van IJzeren decomposition for the Fisher index. Letting <span class="math inline">\(\mathbf{m} =\left(\mathfrak{M}_{\rho_1}(\mathbf{r}, \mathbf{w}_1), \mathfrak{M}_{\rho_2}(\mathbf{r}, \mathbf{w}_2)\right)\)</span> and <span class="math inline">\(\mathbf{\omega} = (\omega_1, \omega_2)\)</span>, this can be written as <span id="eq-res3"><span class="math display">\[
v_{1}(\mathbf{m}, \mathbf{\omega}; \rho, \varsigma) \mathbf{v}(\mathbf{r}, \mathbf{w}_1; \rho_1, \varsigma) + v_{2}(\mathbf{m}, \mathbf{\omega}; \rho, \varsigma) \mathbf{v}(\mathbf{r}, \mathbf{w}_2; \rho_2, \varsigma).  
\tag{5}\]</span></span> Note that for a Fisher index, if <span class="math inline">\(\varsigma=1\)</span> then <span class="math inline">\(\mathbf{v}(\mathbf{r}, \mathbf{w}_1; \rho_1, \varsigma)\)</span> is a vector of base-period expenditure/revenue shares, <span class="math inline">\(\mathbf{v}(\mathbf{r}, \mathbf{w}_2; \rho_2, \varsigma)\)</span> is a vector of hybrid Paasche weights, and <span class="math inline">\(\mathbf{v}(\mathbf{m}, \mathbf{\omega}; \rho, \varsigma)\)</span> are the unique weights that decompose the geometric mean of the Laspeyres and Paasche indexes, which equals the van IJzeren decomposition. The idea here is to transmute the weights for both the inner and outer generalized means so that they are means of order <span class="math inline">\(\varsigma\)</span>, then take the product of these weights. <a href="#eq-res2" class="quarto-xref">Equation&nbsp;4</a> and <a href="#eq-res3" class="quarto-xref">Equation&nbsp;5</a> generally give different decompositions, but reduce to <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a> when <span class="math inline">\(\rho = \rho_{1} = \rho_{2}\)</span> and <span class="math inline">\(\mathbf{w}_{1} = \mathbf{w}_{2}\)</span>.</p>
</section>
<section id="sec-example" class="level3">
<h3 class="anchored" data-anchor-id="sec-example">Numerical example</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gpindex)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> price6[[<span class="dv">2</span>]]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> price6[[<span class="dv">1</span>]]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>q2 <span class="ot">&lt;-</span> quantity6[[<span class="dv">2</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>q1 <span class="ot">&lt;-</span> quantity6[[<span class="dv">1</span>]]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>rel <span class="ot">&lt;-</span> p2 <span class="sc">/</span> p1</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>s2 <span class="ot">&lt;-</span> <span class="fu">scale_weights</span>(p2 <span class="sc">*</span> q1)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>s1 <span class="ot">&lt;-</span> <span class="fu">scale_weights</span>(p1 <span class="sc">*</span> q1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>quadratic_mean <span class="ot">&lt;-</span> <span class="fu">generalized_mean</span>(<span class="dv">2</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>quadratic_weights <span class="ot">&lt;-</span> <span class="fu">transmute_weights</span>(<span class="dv">2</span>, <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">quadratic_mean</span>(rel, s1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.531339</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>v <span class="ot">&lt;-</span> <span class="fu">quadratic_weights</span>(rel, s1)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">arithmetic_mean</span>(rel, v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.531339</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">transmute_weights</span>(<span class="dv">1</span>, <span class="dv">2</span>)(rel, v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.10 0.10 0.20 0.10 0.45 0.05</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>v[<span class="fu">order</span>(rel)] <span class="sc">-</span> s1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -0.024395704 -0.060503706 -0.107454243  0.091868099 -0.003049463
[6]  0.103535017</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>permute <span class="ot">&lt;-</span> <span class="cf">function</span>(x, w, d) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  d2 <span class="ot">&lt;-</span> d <span class="sc">*</span> (x[<span class="dv">3</span>] <span class="sc">-</span> x[<span class="dv">1</span>]) <span class="sc">/</span> (x[<span class="dv">2</span>] <span class="sc">-</span> x[<span class="dv">3</span>])</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  w <span class="sc">+</span> <span class="fu">c</span>(d, d2, <span class="sc">-</span>d <span class="sc">-</span> d2)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>v1 <span class="ot">&lt;-</span> <span class="fu">permute</span>(x, <span class="fu">transmute_weights</span>(<span class="dv">0</span>, <span class="dv">1</span>)(x), <span class="fl">0.1</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(<span class="fu">geometric_mean</span>(x), <span class="fu">arithmetic_mean</span>(x, v1))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>u <span class="ot">&lt;-</span> <span class="fu">transmute_weights</span>(<span class="dv">1</span>, <span class="dv">2</span>)(x, v1)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">permute</span>(rel, u, <span class="dv">1</span> <span class="sc">/</span> <span class="dv">3</span> <span class="sc">-</span> u[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3333333 0.1808477 0.4858190</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-contribution" class="level2">
<h2 class="anchored" data-anchor-id="sec-contribution">Percent-change contributions</h2>
</section>
<section id="sec-simulation" class="level2">
<h2 class="anchored" data-anchor-id="sec-simulation">Contributions for the Fisher index</h2>
</section>
<section id="references" class="level2 unnumbered">


</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-balk2008" class="csl-entry" role="listitem">
Balk, B. M. 2008. <em>Price and Quantity Index Numbers</em>. Cambridge University Press.
</div>
<div id="ref-bullen2003" class="csl-entry" role="listitem">
Bullen, P. S. 2003. <em>Handbook of Means and Their Inequalities</em>. Springer Science+Business Media.
</div>
<div id="ref-diewert2002" class="csl-entry" role="listitem">
Diewert, W. E. 2002. <span>âThe Quadratic Approximation Lemma and Decompositions of Superlative Indexes.â</span> <em>Journal of Economic and Social Measurement</em> 28 (1-2): 63â88.
</div>
<div id="ref-hallerbach2005" class="csl-entry" role="listitem">
Hallerbach, W. G. 2005. <span>âAn Alternative Decomposition of the <span>F</span>isher Index.â</span> <em>Economics Letters</em> 86 (2): 147â52.
</div>
<div id="ref-lent2009" class="csl-entry" role="listitem">
Lent, J., and A. H. Dorfman. 2009. <span>âUsing a Weighted Average of Base Period Price Indexes to Approximate a Superlative Index.â</span> <em>Journal of Official Statistics</em> 25 (1): 149â49.
</div>
<div id="ref-martin2021" class="csl-entry" role="listitem">
Martin, S. 2021. <span>âA Note on Generalized Decompositions for Price Indexes.â</span> Statistics Canada.
</div>
<div id="ref-reinsdorf2002" class="csl-entry" role="listitem">
Reinsdorf, M. B., W. E. Diewert, and C. Ehemann. 2002. <span>âAdditive Decompositions for <span>F</span>isher, <span>TÃ¶</span>rnqvist and Geometric Mean Indexes.â</span> <em>Journal of Economic and Social Measurement</em> 28 (1-2): 51â61.
</div>
<div id="ref-webster2019" class="csl-entry" role="listitem">
Webster, M. B., and R. C. Tarnow-Mordi. 2019. <span>âDecomposing Multilateral Price Indexes into the Contributions of Individual Commodities.â</span> <em>Journal of Official Statistics</em> 35: 461â86.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>There are decompositions with âweightsâ that do not sum to one, such as those for the Fisher index by <span class="citation" data-cites="reinsdorf2002">Reinsdorf, Diewert, and Ehemann (<a href="#ref-reinsdorf2002" role="doc-biblioref">2002, sec. 2</a>)</span> and <span class="citation" data-cites="hallerbach2005">Hallerbach (<a href="#ref-hallerbach2005" role="doc-biblioref">2005</a>)</span>, and for other superlative indexes by <span class="citation" data-cites="diewert2002">Diewert (<a href="#ref-diewert2002" role="doc-biblioref">2002</a>)</span>. <span class="citation" data-cites="balk2008">Balk (<a href="#ref-balk2008" role="doc-biblioref">2008</a>, equation 4.28)</span> gives the original multiplicative decomposition of the Fisher index, due to Vartia, for which the weights also do not sum to one. Some of these will be revisited in <a href="#sec-contribution" class="quarto-xref">Section&nbsp;2</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">â©ï¸</a></p></li>
<li id="fn2"><p>To see this, note that <span class="math inline">\(\mathfrak{E}_{\rho\varsigma}(r_i, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma} \equiv \left(\mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}) r_{i}\right)^\rho\)</span> when <span class="math inline">\(\rho = -1\)</span> and <span class="math inline">\(\varsigma = 1\)</span>, or <span class="math inline">\(\rho = 1\)</span> and <span class="math inline">\(\varsigma = -1\)</span>, and plug this into <a href="#eq-res1" class="quarto-xref">Equation&nbsp;2</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">â©ï¸</a></p></li>
<li id="fn3"><p>To see this, note that <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) \geq w_{i}\)</span> if and only if <span class="math display">\[
\mathfrak{E}_{\rho\varsigma}(r_i, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma} \geq \sum_{j=1}^{n} w_{j} \mathfrak{E}_{\rho\varsigma}(r_j, \mathfrak{M}_{\rho} (\mathbf{r}, \mathbf{w}))^{\rho - \varsigma}.
\]</span> Since the extended mean is strictly increasing in its first argument, the right-hand side is an increasing function if <span class="math inline">\(\rho &gt; \varsigma\)</span>. This inequality is not satisfied for <span class="math inline">\(i=1\)</span> and is strictly satisfied for <span class="math inline">\(i=n\)</span>, so <span class="math inline">\(k\)</span> can then be set to the largest value such that this inequality is not satisfied, and <span class="math inline">\(l\)</span> can be set to the smallest value such that it is strictly satisfied. If <span class="math inline">\(\rho &lt; \varsigma\)</span> then the right-hand side is a decreasing function, so the inequality is not satisfied for <span class="math inline">\(i=n\)</span> and is strictly satisfied for <span class="math inline">\(i=1\)</span>. As before, <span class="math inline">\(k\)</span> can be set to the largest value such that the inequality is strictly satisfied, and <span class="math inline">\(l\)</span> can be set to the smallest value such that it is not satisfied.<a href="#fnref3" class="footnote-back" role="doc-backlink">â©ï¸</a></p></li>
<li id="fn4"><p>When <span class="math inline">\(n=2\)</span>, any other function <span class="math inline">\(u\)</span> that decomposes the generalized mean must satisfy <span class="math inline">\((v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) - u_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma))(r_{1}^\varsigma - r_{2}^\varsigma) \equiv 0\)</span> for <span class="math inline">\(i=1,2\)</span>, or <span class="math inline">\((v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) - u_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma))(\log(r_{1}) - \log(r_{2})) \equiv 0\)</span> when <span class="math inline">\(\varsigma = 0\)</span>, so that <span class="math inline">\(v_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma) \equiv u_{i}(\mathbf{r}, \mathbf{w}; \rho, \varsigma)\)</span> whenever <span class="math inline">\(r_{1} \neq r_{2}\)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">â©ï¸</a></p></li>
<li id="fn5"><p>Take, for example, <span class="math inline">\(\mathbf{r} = (0.5,1,1.5)\)</span> and <span class="math inline">\(\mathbf{w} = (1/6,1/3,1/2)\)</span>. The weighted harmonic mean of <span class="math inline">\(\mathbf{r}\)</span> is 1, which can be computed as an arithmetic mean with weights <span class="math inline">\((1/3,1/3,1/3)\)</span> or <span class="math inline">\((1/4,1/2,1/4)\)</span>. Hence there are multiple additive decompositions for the harmonic mean.<a href="#fnref5" class="footnote-back" role="doc-backlink">â©ï¸</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>